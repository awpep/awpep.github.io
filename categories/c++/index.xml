<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 不会C的菜菜</title><link>https://awpep.github.io/categories/c++/</link><description>Recent content in C++ on 不会C的菜菜</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 28 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://awpep.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++语法笔记</title><link>https://awpep.github.io/p/cpp-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/cpp-tips/</guid><description>关于template 萃取机制 内嵌型别 个人理解，所谓内嵌型别就是在类的内部使用typedef给类型定义别名，常常与模板相结合
举个栗子
class MyClass{ typedef int SubType; ... } 这段代码中MyClass这个类在内部给int取了一个别名叫SubType，于是乎，我可以用MyClass::SubType来指代int
这个操作乍一看有点脱裤子放屁的感觉，事实上其功用远超想象
typename关键字 C++的一般规则是，除了使用typename修饰之外，template内的任何标识符号都被视为一个值而不是一个类别(对象)
假设我希望实现一个模板类，在其内部需要声明一个类型T的内嵌型SubType的指针，于是有了这么一段看似可行代码
template &amp;lt;class T&amp;gt; class MyClass{ T::SubType *ptr }; 事实上，在编译器看来，SubType会被当成一个static成员，于是T::SubType *ptr会被解释为型别T内的数值SubType与ptr的乘积
正确的写法如下
template &amp;lt;class T&amp;gt; class MyClass{ typename T::SubType *ptr; ... }; typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。
迭代器与萃取 迭代器有一个重要的功能，就是实现类似取地址内容的操作，这个操作迭代器在声明时通过重载*实现
现在假设需要实现这么一个函数，参数是一个迭代器，返回值是迭代器指向的内容，一种直观的想法如下
template &amp;lt;class T&amp;gt; struct MyIter { typedef T value_type; // 内嵌型别声明 T* ptr; MyIter(T* p = 0) : ptr(p) {} T&amp;amp; operator*() const { return *ptr; } }; template &amp;lt;class I&amp;gt; (*I) func(I t){ .</description></item><item><title>算法题常用小技巧</title><link>https://awpep.github.io/p/acm-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/acm-tips/</guid><description>常用位运算公式 lowbit：取最后一位1 -x&amp;amp;x
去除最后一位1 (x-1)&amp;amp;x
枚举子集
for(int subset = set; subset; subset = (subset-1)&amp;amp;set) GCC内建位运算函数 int __builtin_ffs(unsigned int x) 返回x中最后一个为1的位是从后向前的第几位，如__builtin_ffs(0x789)=1，__builtin_ffs(0x78c)=3。于是，__builtin_ffs(x) - 1就是x中最后一个为1的位的位置。
int __builtin_popcount(unsigned int x) x中1的个数。
int __builtin_ctz(unsigned int x) x末尾0的个数。x=0时结果未定义。
int __builtin_clz(unsigned int x) x前导0的个数。x=0时结果未定义。
int __builtin_parity(unsigned int x) x中1的奇偶性。
上面的宏中x都是unsigned int型的，如果传入signed或者是char型，会被强制转换成unsigned int。</description></item></channel></rss>