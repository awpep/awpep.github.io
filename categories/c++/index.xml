<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 不会C的菜菜</title><link>https://awpep.github.io/categories/c++/</link><description>Recent content in C++ on 不会C的菜菜</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 26 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://awpep.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Effective C++阅读笔记</title><link>https://awpep.github.io/p/effective-cpp-tips/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/effective-cpp-tips/</guid><description>视C++为一个语言联邦 将C++看作四个次级结构组成的语法体系，每个体系都会有独自的守则
C Object-Oriented C++ Template C++ STL 尽量以const，enum，inline替换#define 例1 例如以下两行代码
#define ASPECT_RATIO 1.653 const double AspectRatio = 1.653; 前者在编译器处理时，仅仅进行简单的替换，而后者为实实在在的变量， 如果在代码中出错，前者在错误信息中会被识别为1.653，而后者会被识别为AspectRatio 显然带有语义的变量能够帮助我们更快地定位问题所在
确定对象被使用前已被初始化 用初始化列表代替赋值 这在效率上更有优势，如下例：
class PhoneNumber {...}; class ABEntry { public: ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones); private: std::string theName; std::string theAddress; std::list&amp;lt;PhoneNumber&amp;gt; thePhones; int numTimesConsulted; } // 使用赋值的方式进行初始化 ABEntry::ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; } // 使用初始化列表 ABEntry::ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones) :theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) {} 使用赋值的方式进行初始化将会先调用成员数据类型的default构造函数， 而后进行拷贝赋值，如此一来，default构造函数相当于做了无用功</description></item><item><title>C++语法笔记</title><link>https://awpep.github.io/p/cpp-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/cpp-tips/</guid><description>关于cv关键字 本节搬运自const关键字放在“类型前”与“类型后”
char * const cp //定义一个指向字符的指针常数 const char* p //定义一个指向字符常数的指针 char const* p //等同于const char* p 关于const unordered_map的特殊之处 const unordered_map不能使用[]重载
//@{ /** * @brief Subscript ( @c [] ) access to %unordered_map data. * @param __k The key for which data should be retrieved. * @return A reference to the data of the (key,data) %pair. * * Allows for easy lookup with the subscript ( @c [] )operator. Returns * data associated with the key specified in subscript.</description></item><item><title>算法题常用小技巧</title><link>https://awpep.github.io/p/acm-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/acm-tips/</guid><description>常用位运算公式 lowbit：取最后一位1 -x&amp;amp;x
去除最后一位1 (x-1)&amp;amp;x
枚举子集
for(int subset = set; subset; subset = (subset-1)&amp;amp;set) GCC内建位运算函数 int __builtin_ffs(unsigned int x) 返回x中最后一个为1的位是从后向前的第几位，如__builtin_ffs(0x789)=1，__builtin_ffs(0x78c)=3。于是，__builtin_ffs(x) - 1就是x中最后一个为1的位的位置。
int __builtin_popcount(unsigned int x) x中1的个数。
int __builtin_ctz(unsigned int x) x末尾0的个数。x=0时结果未定义。
int __builtin_clz(unsigned int x) x前导0的个数。x=0时结果未定义。
int __builtin_parity(unsigned int x) x中1的奇偶性。
上面的宏中x都是unsigned int型的，如果传入signed或者是char型，会被强制转换成unsigned int。
质因数分解 参考来源：力扣（LeetCode）
作者：xin-xiang-yuan-fang
源码 // 质因数分解 vector&amp;lt;int&amp;gt; vec; for (int i = 2; i &amp;lt;= n/i; ++i) { bool flag = false; while (n % i == 0) { n /= i; flag = true; } if(flag) vec.</description></item></channel></rss>