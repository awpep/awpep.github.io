<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>STM32 on 不会C的菜菜</title><link>https://awpep.github.io/tags/stm32/</link><description>Recent content in STM32 on 不会C的菜菜</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 20 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://awpep.github.io/tags/stm32/index.xml" rel="self" type="application/rss+xml"/><item><title>关于STM32F429中定时器的触发问题</title><link>https://awpep.github.io/p/about-stm32f429-timer/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/about-stm32f429-timer/</guid><description>搬运自我的CSDN博客
帮老师做项目的时候遇到了一个奇怪的问题 因为需要几个定时器同步，因此将其中一个定时器配置成主模式，将使能信号作为触发源输出，其他定时器作为从模式触发 但是高级定时器总是莫名其妙被先行被触发，排查后发现，原因来自TimeBaseInit函数，函数原型如下
/** * @brief Initializes the TIMx Time Base Unit peripheral according to * the specified parameters in the TIM_TimeBaseInitStruct. * @param TIMx: where x can be 1 to 14 to select the TIM peripheral. * @param TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure * that contains the configuration information for the specified TIM peripheral. * @retval None */ void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct) { uint16_t tmpcr1 = 0; /* Check the parameters */ assert_param(IS_TIM_ALL_PERIPH(TIMx)); assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&amp;gt;TIM_CounterMode)); assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&amp;gt;TIM_ClockDivision)); tmpcr1 = TIMx-&amp;gt;CR1; if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)|| (TIMx == TIM4) || (TIMx == TIM5)) { /* Select the Counter Mode */ tmpcr1 &amp;amp;= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS)); tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct-&amp;gt;TIM_CounterMode; } if((TIMx !</description></item></channel></rss>