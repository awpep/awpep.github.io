<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>语法 on 不会C的菜菜</title><link>https://awpep.github.io/tags/%E8%AF%AD%E6%B3%95/</link><description>Recent content in 语法 on 不会C的菜菜</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 28 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://awpep.github.io/tags/%E8%AF%AD%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>C++语法笔记</title><link>https://awpep.github.io/p/cpp-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/cpp-tips/</guid><description>关于template 萃取机制 内嵌型别 个人理解，所谓内嵌型别就是在类的内部使用typedef给类型定义别名，常常与模板相结合
举个栗子
class MyClass{ typedef int SubType; ... } 这段代码中MyClass这个类在内部给int取了一个别名叫SubType，于是乎，我可以用MyClass::SubType来指代int
这个操作乍一看有点脱裤子放屁的感觉，事实上其功用远超想象
typename关键字 C++的一般规则是，除了使用typename修饰之外，template内的任何标识符号都被视为一个值而不是一个类别(对象)
假设我希望实现一个模板类，在其内部需要声明一个类型T的内嵌型SubType的指针，于是有了这么一段看似可行代码
template &amp;lt;class T&amp;gt; class MyClass{ T::SubType *ptr }; 事实上，在编译器看来，SubType会被当成一个static成员，于是T::SubType *ptr会被解释为型别T内的数值SubType与ptr的乘积
正确的写法如下
template &amp;lt;class T&amp;gt; class MyClass{ typename T::SubType *ptr; ... }; typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。
迭代器与萃取 迭代器有一个重要的功能，就是实现类似取地址内容的操作，这个操作迭代器在声明时通过重载*实现
现在假设需要实现这么一个函数，参数是一个迭代器，返回值是迭代器指向的内容，一种直观的想法如下
template &amp;lt;class T&amp;gt; struct MyIter { typedef T value_type; // 内嵌型别声明 T* ptr; MyIter(T* p = 0) : ptr(p) {} T&amp;amp; operator*() const { return *ptr; } }; template &amp;lt;class I&amp;gt; (*I) func(I t){ .</description></item></channel></rss>