[{"content":"正文测试 阿巴阿巴阿巴\n","date":"2021-07-21T00:00:00Z","image":"https://awpep.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://awpep.github.io/p/test-chinese/","title":"中文测试"},{"content":"搬运自我的CSDN博客\nt连接Mysql的时候出现了驱动没有装载的情况，在网上找了很多方法，最终成功使得available drivers当中出现了QMYSQL，但是依然无法加载驱动，折腾了半天终于跟着官方文档解决了问题。想起以前也这么折腾过一次，吸取教训，赶紧记录一下以防日后又忘记。\n背景 Qt版本：Qt 5.13.0 编译器：mingw73_64 MySQL：MySQL Connector C 6.1.11，这里没有安装完整的MySQL，因为仅仅需要连接服务器上的数据库\n踩坑过程 根据网上大部分人的方法，使用Qt的图形化界面对sqldriver目录下mysql.pro进行编译，我的目录是\nF:\\Softwares\\Qt\\5.13.0\\Src\\qtbase\\src\\plugins\\sqldrivers\\mysql 然后把编译生成的两个dll文件，copy至编译器的sqldrivers目录下，我的目录是\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\plugins\\sqldrivers 最后再把MySQL的libmysql.dll复制到编译器的bin目录下，我的目录是\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\bin 然而，编译完成后，结果如下\n可以说，非常的难受\n解决方法 最后在Qt官网找到了解决方案，根据官网的说明，实际上仅需下载MySQL Connector C，另外官网也给了说明\n Note: As of MySQL 8.0.19, the C Connector is no longer offered as a standalone installable component. Instead, you can get mysql.h and libmysql.* by installing the full MySQL Server (x64 only) or the MariaDB C Connector.\n 从8.0.19版本开始不再提供独立的Connector C了\n这里要确定64位的connector要对应64位的Qt，我选择的是64位Archive版(免安装)，确认有以下三个文件\n\u0026lt;MySQL dir\u0026gt;/lib/libmysql.lib \u0026lt;MySQL dir\u0026gt;/lib/libmysql.dll \u0026lt;MySQL dir\u0026gt;/include/mysql.h 随后，打开Qt的命令行工具Qt 5.13.0 (MinGW 7.3.0 64-bit)，输入以下指令\ncd %QTDIR%\\qtbase\\src\\plugins\\sqldrivers qmake -- MYSQL_INCDIR=\u0026quot;C:/Program Files/MySQL/MySQL Connector C 6.1/include\u0026quot; MYSQL_LIBDIR=\u0026quot;C:/Program Files/MySQL/MySQL Connector C 6.1/lib\u0026quot; mingw32-make sub-mysql mingw32-make install 需要将MYSQL_INCDIR和MYSQL_LIBDIR后的路径替换成自己的，例如我的地址是\nMYSQL_INCDIR=\u0026quot;F:\\Tools\\mysql connector c 6.1.11\\include\u0026quot; MYSQL_LIBDIR=\u0026quot;F:\\Tools\\mysql connector c 6.1.11\\lib\u0026quot; 运行完以后会在以下目录生成两个dll文件qsqlmysql.dll、qsqlmysqld.dll（以我为例）\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\plugins\\sqldrivers 最后，再将libmysql.dll复制到以下目录即可（以我为例）\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\bin ","date":"2020-05-05T00:00:00Z","image":"https://awpep.github.io/p/about-qmysql-error-solution/Qt_hu0c217fc96746f2cbd58fdf71d137cebd_35026_120x120_fill_box_smart1_2.png","permalink":"https://awpep.github.io/p/about-qmysql-error-solution/","title":"关于Qt中出现QSqlDatabase: QMYSQL driver not loaded的解决方案"},{"content":"搬运自我的CSDN博客\n帮老师做项目的时候遇到了一个奇怪的问题 因为需要几个定时器同步，因此将其中一个定时器配置成主模式，将使能信号作为触发源输出，其他定时器作为从模式触发 但是高级定时器总是莫名其妙被先行被触发，排查后发现，原因来自TimeBaseInit函数，函数原型如下\n/** * @brief Initializes the TIMx Time Base Unit peripheral according to * the specified parameters in the TIM_TimeBaseInitStruct. * @param TIMx: where x can be 1 to 14 to select the TIM peripheral. * @param TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure * that contains the configuration information for the specified TIM peripheral. * @retval None */ void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct) { uint16_t tmpcr1 = 0; /* Check the parameters */ assert_param(IS_TIM_ALL_PERIPH(TIMx)); assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-\u0026gt;TIM_CounterMode)); assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-\u0026gt;TIM_ClockDivision)); tmpcr1 = TIMx-\u0026gt;CR1; if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)|| (TIMx == TIM4) || (TIMx == TIM5)) { /* Select the Counter Mode */ tmpcr1 \u0026amp;= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS)); tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct-\u0026gt;TIM_CounterMode; } if((TIMx != TIM6) \u0026amp;\u0026amp; (TIMx != TIM7)) { /* Set the clock division */ tmpcr1 \u0026amp;= (uint16_t)(~TIM_CR1_CKD); tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct-\u0026gt;TIM_ClockDivision; } TIMx-\u0026gt;CR1 = tmpcr1; /* Set the Autoreload value */ TIMx-\u0026gt;ARR = TIM_TimeBaseInitStruct-\u0026gt;TIM_Period ; /* Set the Prescaler value */ TIMx-\u0026gt;PSC = TIM_TimeBaseInitStruct-\u0026gt;TIM_Prescaler; if ((TIMx == TIM1) || (TIMx == TIM8)) { /* Set the Repetition Counter value */ TIMx-\u0026gt;RCR = TIM_TimeBaseInitStruct-\u0026gt;TIM_RepetitionCounter; } /* Generate an update event to reload the Prescaler and the repetition counter(only for TIM1 and TIM8) value immediately */ TIMx-\u0026gt;EGR = TIM_PSCReloadMode_Immediate; } 可以看到里面有这么一句\n/* Generate an update event to reload the Prescaler and the repetition counter(only for TIM1 and TIM8) value immediately */ TIMx-\u0026gt;EGR = TIM_PSCReloadMode_Immediate; 注释上写的大概意思是通过产生一个更新事件来立即重载预分频寄存器和重复计数寄存器查参考手册找TIM8的EGR寄存器\n继续查右值，发现是个宏\n#define TIM_PSCReloadMode_Immediate ((uint16_t)0x0001) UG位的作用\n作用注释已经解释了，官方的参考手册里面也有讲，是使用更新事件来确保各个装在入影子寄存器的值立即更新，这是一种官方推荐的初始化定时器的方式我的代码里，是先初始化高级定时器，然后初始化通用定时器，高级定时器使用通用定时器作为触发源\n//设置为从模式，用TIM4触发 TIM_SelectSlaveMode(TIM8, TIM_SlaveMode_Trigger); TIM_SelectInputTrigger(TIM8, TIM_TS_ITR2); 然而，当代码运行到通用定时器初始化时，发现TIM8神奇的被触发了，通过之前的分析感觉是UG的问题 可是，我TIM4输出的触发信号明明是使能信号\n//主模式 //该函数是用作主定时器与从定时器触发的同步，并不是设置主定时器 TIM_SelectMasterSlaveMode(TIM4, TIM_MasterSlaveMode_Enable); TIM_SelectOutputTrigger(TIM4, TIM_TRGOSource_Enable); 后来一想，运行到TimeBaseInit时，我还没设置输出的触发源，会不会是这个问题再查数据手册，管理触发源的是CR2寄存器的MMS\n可以看到，复位值是000，那么MMS是000的时候会怎么样呢？\n the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.TIMx_EGR寄存器中的UG位用作触发输出（TRGO）。 如果复位是由触发输入（从机模式控制器配置为复位模式）产生的，则TRGO上的信号与实际复位相比会延迟。\n 至此，终于破案了截图均来自STM32F429参考手册 RM0090 Rev 18\n","date":"2019-12-20T00:00:00Z","image":"https://awpep.github.io/p/about-stm32f429-timer/STM32_huac24df2c7fde356d310dbb0cd27b8db0_1376535_120x120_fill_box_smart1_2.png","permalink":"https://awpep.github.io/p/about-stm32f429-timer/","title":"关于STM32F429中定时器的触发问题"}]