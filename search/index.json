[{"content":"maven maven的生命周期 maven有三套独立的生命周期：clean、default、site\n每个生命周期又包含了多个阶段。这些阶段在执行的时候是有固定顺序的。后面的阶段一定要等前面的阶段执行完成后才能被执行。\nclean 包含三个阶段：\n pre-clean：执行清理前需要完成的工作。 clean：清理上一次构建过程中生成的文件，比如编译后的 class 文件等。 post-clean：执行清理后需要完成的工作。  default    名称 说明     validate 验证项目结构是否正常，必要的配置文件是否存在   initialize 做构建前的初始化操作，比如初始化参数、创建必要的目录等   generate-sources 产生在编译过程中需要的源代码   process-sources 处理源代码，比如过滤值   generate-resources 产生主代码中的资源在 classpath 中的包   process-resources 将资源文件复制到 classpath 的对应包中   compile 编译项目中的源代码   process-classes 产生编译过程中生成的文件   generate-test-sources 产生编译过程中测试相关的代码   process-test-sources 处理测试代码   generate-test-resources 产生测试中资源在 classpath 中的包   process-test-resources 将测试资源复制到 classpath 中   test-compile 编译测试代码   process-test-classes 产生编译测试代码过程的文件   test 运行测试案例   prepare-package 处理打包前需要初始化的准备工作   package 将编译后的 class 和资源打包成压缩文件，比如 rar   pre-integration-test 做好集成测试前的准备工作，比如集成环境的参数设置   integration-test 集成测试   post-integration-test 完成集成测试后的收尾工作，比如清理集成环境的值   verify 检测测试后的包是否完好   install 将打包的组件以构件的形式，安装到本地依赖仓库中，以便共享给本地的其他项目   deploy 运行集成和发布环境，将测试后的最终包以构件的方式发布到远程仓库中，方便所有程序员共享    site  pre-site：执行生成站点前的准备工作。 site：生成站点文档。 post-site：执行生成站点后需要收尾的工作。 site-deploy：将生成的站点发布到服务器上。  ","date":"2022-05-21T00:00:00Z","permalink":"https://awpep.github.io/p/java-tips/","title":"Java学习笔记"},{"content":"视C++为一个语言联邦 将C++看作四个次级结构组成的语法体系，每个体系都会有独自的守则\n C Object-Oriented C++ Template C++ STL  尽量以const，enum，inline替换#define 例1 例如以下两行代码\n#define ASPECT_RATIO 1.653 const double AspectRatio = 1.653; 前者在编译器处理时，仅仅进行简单的替换，而后者为实实在在的变量， 如果在代码中出错，前者在错误信息中会被识别为1.653，而后者会被识别为AspectRatio 显然带有语义的变量能够帮助我们更快地定位问题所在\n确定对象被使用前已被初始化 用初始化列表代替赋值 这在效率上更有优势，如下例：\nclass PhoneNumber {...}; class ABEntry { public: ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones); private: std::string theName; std::string theAddress; std::list\u0026lt;PhoneNumber\u0026gt; thePhones; int numTimesConsulted; } // 使用赋值的方式进行初始化 ABEntry::ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; } // 使用初始化列表 ABEntry::ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) :theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) {} 使用赋值的方式进行初始化将会先调用成员数据类型的default构造函数， 而后进行拷贝赋值，如此一来，default构造函数相当于做了无用功\n初始化顺序  基类早于派生类 成员变量按照声明的顺序  local static与non-local static对象 static对象包括global对象、定义于namespace作用域内的对象、 在class内、函数内、文件作用域内被声明为static的对象\n函数内的static对象称作local static对象，其余称为non-local static对象\n编译单元：产出单一目标文件的源码\n假设某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，这将导致它所用到的这个对象可能尚未被初始化\n// 这是一个文件 class FileSystem { public: ... std::size_t numDisks() const; ... }; extern FileSystem tfs; // 这是另一个文件 class Directory { public: Directory(params); ... }; Directory::Directory(params) { ... std::size_t disks = tfs.numDisks(); ... } Directory tempDir(params); 了解C++默默编写并调用哪些函数 编译器会默认生成以下成员函数 class Empty {}; class Empty { public: Empty() {...} // defualt构造函数  Empty(const Empty\u0026amp; rhs) {...} // copy构造函数  ~Empty() {...} // 析构函数  // copy assignment操作符  Empty\u0026amp; operator=(const Empty\u0026amp; rhs) {...} } 以上两种写法是等价的\n一种不可赋值类的写法 class Uncopyable { protected: // 允许构造和析构  Uncopyable() {} ~Uncopyable() {} private: // 阻止copying  Uncopyable(const Uncopyable\u0026amp;); Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); } class HomeForSale: private Uncopyable() { ... }; 只要HomeforSale类不主动定义拷贝构造和拷贝赋值函数， 那么编译器自动生成的默认拷贝构造和拷贝赋值函数将调用基类的这类函数， 因而，尝试拷贝HomeforSale的操作会被拒绝\n如果重写了拷贝赋值函数，一定要显式地调用基类的拷贝赋值函数 考虑如下情况\n// 基类 class Customer { public: Customer(std::string name = \u0026#34;lucy\u0026#34;); Customer(const Customer\u0026amp;); Customer\u0026amp; operator=(const Customer\u0026amp;); void printname(void); private: std::string name; }; // 派生类 class PriorityCustomer: public Customer { public: PriorityCustomer(std::string name = \u0026#34;lucy\u0026#34;, int priority = 0); PriorityCustomer(const PriorityCustomer\u0026amp;); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp;); private: int priority; }; 如果不主动定义派生类的拷贝赋值函数，那么编译器生成的拷贝赋值函数将自动地调用 基类的拷贝赋值函数，否则就一定要显式地调用基类的拷贝赋值函数\n// 拷贝赋值函数 PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { std::cout \u0026lt;\u0026lt; \u0026#34;PriorityCustomer copy assignment operator\u0026#34; \u0026lt;\u0026lt; std::endl; // 如果重写了拷贝赋值，一定要显式调用基类的拷贝赋值函数  Customer::operator=(rhs); priority = rhs.priority; return *this; } ","date":"2021-08-26T00:00:00Z","permalink":"https://awpep.github.io/p/effective-cpp-tips/","title":"Effective C++阅读笔记"},{"content":"关于cv关键字 本节搬运自const关键字放在“类型前”与“类型后”\nchar * const cp //定义一个指向字符的指针常数 const char* p //定义一个指向字符常数的指针 char const* p //等同于const char* p 关于const unordered_map的特殊之处 const unordered_map不能使用[]重载\n//@{  /** * @brief Subscript ( @c [] ) access to %unordered_map data. * @param __k The key for which data should be retrieved. * @return A reference to the data of the (key,data) %pair. * * Allows for easy lookup with the subscript ( @c [] )operator. Returns * data associated with the key specified in subscript. If the key does * not exist, a pair with that key is created using default values, which * is then returned. * * Lookup requires constant time. */ mapped_type\u0026amp; operator[](const key_type\u0026amp; __k) { return _M_h[__k]; } mapped_type\u0026amp; operator[](key_type\u0026amp;\u0026amp; __k) { return _M_h[std::move(__k)]; } //@}  //@{  /** * @brief Access to %unordered_map data. * @param __k The key for which data should be retrieved. * @return A reference to the data whose key is equal to @a __k, if * such a data is present in the %unordered_map. * @throw std::out_of_range If no such data is present. */ mapped_type\u0026amp; at(const key_type\u0026amp; __k) { return _M_h.at(__k); } const mapped_type\u0026amp; at(const key_type\u0026amp; __k) const { return _M_h.at(__k); } []没有带const的重载，但at有，可以用at代替，对map同理\n关于求值顺序 本节搬运自【部分原创】标准C语言的优先级、结合性、求值顺序、未定义行为和非确定行为浅析\n在C语言中，仅有少数运算符在标准中有规定表达式求值的顺序\n逻辑与或 \u0026amp;\u0026amp;和||规定从左到右求值，并且在能确定整个表达式的值的时候就会停止，也就是 常说的短路\nint x = 1, y = 1, z= 1; ++x || ++y \u0026amp;\u0026amp; ++z; //结果：x == 2, y == 1, z == 1 条件表达式 条件表达式的求值顺序是这样规定的：\ntest ? exp1 ： exp2; 条件测试部分test非零，表达式exp1被求值，否则表达式exp2被求值，并且保证exp1和exp2两者之中只有一个被求值\nint x = 0, y = 0, z = 0; ++x || ++y \u0026amp;\u0026amp; ++z ? ++y : ++z; //结果：x == 1, y == 1, z == 0; 逗号运算符 逗号运算符的求值顺序是从左到右顺序求值，并且整个表达式的值等于最后一个表达式的值，注意逗号,还可以作为函数参数的分隔符，变量定义的分隔符等，这时候表达式的求值顺序是没有规定的！\nint x = 0, y = 0; if(++x, y) cout \u0026lt;\u0026lt; \u0026#34;1st\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;2nd\u0026#34; \u0026lt;\u0026lt; endl; //结果：2nd 关于template 萃取机制 内嵌型别 个人理解，所谓内嵌型别就是在类的内部使用typedef给类型定义别名，常常与模板相结合\n举个栗子\nclass MyClass{ typedef int SubType; ... } 这段代码中MyClass这个类在内部给int取了一个别名叫SubType，于是乎，我可以用MyClass::SubType来指代int\n这个操作乍一看有点脱裤子放屁的感觉，事实上其功用远超想象\ntypename关键字 C++的一般规则是，除了使用typename修饰之外，template内的任何标识符号都被视为一个值而不是一个类别(对象)\n假设我希望实现一个模板类，在其内部需要声明一个类型T的内嵌型SubType的指针，于是有了这么一段看似可行代码\ntemplate \u0026lt;class T\u0026gt; class MyClass{ T::SubType *ptr }; 事实上，在编译器看来，SubType会被当成一个static成员，于是T::SubType *ptr会被解释为型别T内的数值SubType与ptr的乘积\n正确的写法如下\ntemplate \u0026lt;class T\u0026gt; class MyClass{ typename T::SubType *ptr; ... }; typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。\n迭代器与萃取 迭代器有一个重要的功能，就是实现类似取地址内容的操作，这个操作迭代器在声明时通过重载*实现\n现在假设需要实现这么一个函数，参数是一个迭代器，返回值是迭代器指向的内容，一种直观的想法如下\ntemplate \u0026lt;class T\u0026gt; struct MyIter { typedef T value_type; // 内嵌型别声明  T* ptr; MyIter(T* p = 0) : ptr(p) {} T\u0026amp; operator*() const { return *ptr; } }; template \u0026lt;class I\u0026gt; (*I) func(I t){ ... } 但是，这种写法是不行的，问题颇多\n首先(*T)会被理解为一种操作而非类型声明，就好像*MyIter，对一个类，而非对象取址，不伦不类\n那，如果加上typname呢？\n很遗憾，也不可以，typename只对T内部的标识符号起作用\n这时就需要利用内嵌型别声明\ntemplate \u0026lt;class T\u0026gt; struct MyIter { typedef T value_type; // 内嵌型别声明  T* ptr; MyIter(T* p = 0) : ptr(p) {} T\u0026amp; operator*() const { return *ptr; } }; template \u0026lt;class I\u0026gt; typename I::value_type func(I ite) { std::cout \u0026lt;\u0026lt; \u0026#34;class version\u0026#34; \u0026lt;\u0026lt; std::endl; return *ite; } int main() { // ...  MyIter\u0026lt;int\u0026gt; ite(new int(8)); cout \u0026lt;\u0026lt; func(ite); // 输出8 } 看似很ok，但是如果传入的是一个原生指针，例如int*，那么编译就无法通过\n可以用偏特化解决\ntemplate \u0026lt;class T\u0026gt; struct MyIter { typedef T value_type; // 内嵌型别声明  T* ptr; MyIter(T* p = 0) : ptr(p) {} T\u0026amp; operator*() const { return *ptr; } }; template \u0026lt;class I\u0026gt; typename I::value_type func(I ite) { std::cout \u0026lt;\u0026lt; \u0026#34;class version\u0026#34; \u0026lt;\u0026lt; std::endl; return *ite; } template \u0026lt;class I\u0026gt; I func(I* ite) { std::cout \u0026lt;\u0026lt; \u0026#34;pointer version\u0026#34; \u0026lt;\u0026lt; std::endl; return *ite; } template \u0026lt;class I\u0026gt; I func(const I* ite) { std::cout \u0026lt;\u0026lt; \u0026#34;const pointer version\u0026#34; \u0026lt;\u0026lt; std::endl; return *ite; } int main() { // ...  MyIter\u0026lt;int\u0026gt; ite(new int(8)); cout \u0026lt;\u0026lt; func(ite)\u0026lt;\u0026lt;endl; int *p = new int(52); cout\u0026lt;\u0026lt;func(p)\u0026lt;\u0026lt;endl; const int k = 3; cout\u0026lt;\u0026lt;func(\u0026amp;k)\u0026lt;\u0026lt;endl; } 但是，如此这般需要对每一个函数都进行偏特化，会造成大量的代码冗余，为了提高代码重用，STL加入了一个中间层，也就是iterator_Traits\ntemplate \u0026lt;class T\u0026gt; struct MyIter { typedef T value_type; // 内嵌型别声明  T* ptr; MyIter(T* p = 0) : ptr(p) {} T\u0026amp; operator*() const { return *ptr; } }; // class type template \u0026lt;class T\u0026gt; struct iterator_traits { typedef typename T::value_type value_type; }; // 偏特化1 template \u0026lt;class T\u0026gt; struct iterator_traits\u0026lt;T*\u0026gt; { typedef T value_type; }; // 偏特化2 template \u0026lt;class T\u0026gt; struct iterator_traits\u0026lt;const T*\u0026gt; { typedef T value_type; }; template \u0026lt;class I\u0026gt; typename iterator_traits\u0026lt;I\u0026gt;::value_type // 首先询问iterator_traits\u0026lt;I\u0026gt;::value_type,如果传递的I为指针,则进入特化版本,iterator_traits直接回答;如果传递进来的I为class type,就去询问T::value_type. func(I ite) { std::cout \u0026lt;\u0026lt; \u0026#34;normal version\u0026#34; \u0026lt;\u0026lt; std::endl; return *ite; } int main() { // ...  MyIter\u0026lt;int\u0026gt; ite(new int(8)); std::cout \u0026lt;\u0026lt; func(ite)\u0026lt;\u0026lt;std::endl; int *p = new int(52); std::cout\u0026lt;\u0026lt;func(p)\u0026lt;\u0026lt;std::endl; const int k = 3; std::cout\u0026lt;\u0026lt;func(\u0026amp;k)\u0026lt;\u0026lt;std::endl; } 萃取机制为模板使用中的类型声明问题提供了一种通用的实现方式，避免了使用value_types的函数都需要进行偏特化设计的尴尬\n引用和指针的区别 本节搬运自C++中指针与引用的区别，略有改动\n两者的定义和性质不同  指针是一个变量，存储的是一个地址，指向内存的一个存储单元 引用是原变量的一个别名，跟原来的变量实质上是同一个东西  指针可以套娃，引用不行 指针可以有多级指针，多级的引用会触发引用折叠\nint **p; // 二级指针 int \u0026amp;\u0026amp;p; // 右值引用 // \u0026amp;\u0026amp; \u0026amp; 折叠为 \u0026amp; // \u0026amp; \u0026amp;\u0026amp; 折叠为 \u0026amp; // \u0026amp;\u0026amp; \u0026amp;\u0026amp; 折叠为 \u0026amp;\u0026amp; 换句话说：指针的指针是二级指针，而引用的引用，还是引用\n引用必须初始化，且初始化后不能再转而引用其他变量 int *p; // 合法 int \u0026amp;p; // 非法 指针可以指向NULL，引用不可以为NULL int *p = NULL; // 合法 int \u0026amp;r = NULL; // 非法 其他可以以第一点概括  sizeof 的运算结果不同 运算意义不同  右值\u0026amp;右值引用 右值可以分成两种：\n 纯右值（Pure value，简称 pvalue） 将亡值（eXpiring value，简称 xvalue ）     引用类型 非常量左值 常量左值 非常量右值 常量右值 使用场景     非常量左值引用 Y N N N 无   常量左值引用 Y Y Y Y 常用于类中构建拷贝构造函数   非常量右值引用 N N Y N 移动语义、完美转发   常量右值引用 N N Y Y 无实际用途    关于完美转发和引用折叠 template\u0026lt;typename T\u0026gt; void print(T \u0026amp; t){ std::cout \u0026lt;\u0026lt; \u0026#34;左值\u0026#34; \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T\u0026gt; void print(T \u0026amp;\u0026amp; t){ std::cout \u0026lt;\u0026lt; \u0026#34;右值\u0026#34; \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T\u0026gt; void testForward(T \u0026amp;\u0026amp; v){ print(v); print(std::forward\u0026lt;T\u0026gt;(v)); print(std::move(v)); } int main(int argc, char * argv[]) { testForward(1); std::cout \u0026lt;\u0026lt; \u0026#34;======================\u0026#34; \u0026lt;\u0026lt; std::endl; int x = 1; testForward(x); return 0; } // 运行结果： // 左值 // 右值 // 右值 // ====================== // 左值 // 左值 // 右值 右值引用是左值！！！ C++不允许引用的引用，模板类会将其折叠， 仅当两次引用均为右值引用时才会折叠为右值引用，否则折叠为左值引用\n关于sort的第三参数 compare的实现要求  对于任意元素a，需满足comp(a, a) == false 对于任意两个元素a和b，若comp(a, b)==true则要满足comp(b, a)==false 对于任意三个元素a、b和c，若comp(a, b)==true且comp(b, c)==true则需要满足comp(a, c)==true  sort中容易出问题的片段 /// This is a helper function for the sort routine. template\u0026lt;typename _RandomAccessIterator, typename _Compare\u0026gt; void __unguarded_linear_insert(_RandomAccessIterator __last, _Compare __comp) { typename iterator_traits\u0026lt;_RandomAccessIterator\u0026gt;::value_type __val = _GLIBCXX_MOVE(*__last); _RandomAccessIterator __next = __last; --__next; while (__comp(__val, __next)) { *__last = _GLIBCXX_MOVE(*__next); __last = __next; --__next; } *__last = _GLIBCXX_MOVE(__val); } 很显然，在sort运行到以上函数的时候，如果剩余元素全部相同，那么循环就会一直持续下去直到越界\n构造一个导致sort崩溃的例程 int main() { vector\u0026lt;int\u0026gt; nums(17,1); auto cmp = [](int a, int b) {return a \u0026gt;= b;}; sort(nums.begin(),nums.end(),cmp); return 0; } 前16个元素会使用正常的插入排序，后面的元素才会使用无保护的插入排序\n变量的声明和定义  声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明 定义负责创建与名字关联的实体，需要申请存储空间  extern int var; // 声明 extern int ble = 10; // 定义 typedef int INT; // 声明 struct Node; // 声明  int value; // 声明+定义  struct Node { // 声明+定义  int left; int right; }; 关于四大转型 static_cast  编译器隐式执行的任何类型转换都可以由static_cast来完成，比如int与float、double与char、enum与int之间的转换等 static_cast还能进行向下转型 class Base{ }; class Derived : public Base{ }; Base* B; Derived* D; D = static_cast\u0026lt;Derived*\u0026gt;(B); // 正确，通过使用static_cast向下转型 D = B; // 错误，不能隐式地向下转型   参考  const关键字放在“类型前”与“类型后” 【部分原创】标准C语言的优先级、结合性、求值顺序、未定义行为和非确定行为浅析 C++模板之typename和class关键字的区别 C++ STL 源码剖析之 Traits 编程技法 C++中指针与引用的区别 C++11右值引用（一看即懂） 聊聊C++中的完美转发 C++中使用std::sort自定义排序规则时要注意的崩溃问题 【C/C++面试必备】声明和定义的区别  ","date":"2021-07-28T00:00:00Z","permalink":"https://awpep.github.io/p/cpp-tips/","title":"C++语法笔记"},{"content":"常用位运算公式 lowbit：取最后一位1 -x\u0026amp;x\n去除最后一位1 (x-1)\u0026amp;x\n枚举子集\nfor(int subset = set; subset; subset = (subset-1)\u0026amp;set) GCC内建位运算函数 int __builtin_ffs(unsigned int x) 返回x中最后一个为1的位是从后向前的第几位，如__builtin_ffs(0x789)=1，__builtin_ffs(0x78c)=3。于是，__builtin_ffs(x) - 1就是x中最后一个为1的位的位置。\nint __builtin_popcount(unsigned int x) x中1的个数。\nint __builtin_ctz(unsigned int x) x末尾0的个数。x=0时结果未定义。\nint __builtin_clz(unsigned int x) x前导0的个数。x=0时结果未定义。\nint __builtin_parity(unsigned int x) x中1的奇偶性。\n上面的宏中x都是unsigned int型的，如果传入signed或者是char型，会被强制转换成unsigned int。\n质因数分解 参考来源：力扣（LeetCode）\n作者：xin-xiang-yuan-fang\n源码 // 质因数分解 vector\u0026lt;int\u0026gt; vec; for (int i = 2; i \u0026lt;= n/i; ++i) { bool flag = false; while (n % i == 0) { n /= i; flag = true; } if(flag) vec.push_back(i); } if (n \u0026gt; 1) vec.push_back(n); 关于界限i \u0026lt;= c/i 众所周知，除法的运算时间远大于乘法 但这里写成i \u0026lt;= c/i 而不是 i*i \u0026lt;= c是为了防止i*i溢出 作为界限，这两个式子在不溢出时是等价的\n那，为什么不是i \u0026lt;= c呢？\n经过之前的运算，剩余的c当中已经不包含小于i的因数， 如果1 \u0026lt; c \u0026lt; i*i那么c一定是质数\n为什么获得的因数一定是质数 如果i是合数，那么一定能分解成i==a*b的形式， 其中至少a为质数，且a和b都小于i， 如之前所言，剩余的c当中一定不包含小于i的因数， 因此，如果i是c的因数，那么i一定是质数\n线性素数筛 源码 // 欧拉筛 vector\u0026lt;int\u0026gt; Euler_prime(int n) { vector\u0026lt;int\u0026gt; prime; vector\u0026lt;bool\u0026gt; vis(n+1,false); for(int i=2;i\u0026lt;=n;++i) { if(!vis[i]) { prime.push_back(i); vis[i]=true; } for(const auto\u0026amp; p: prime) { if(i*p\u0026gt;n) break; // 判断是否越界  vis[i*p]=true; // 筛数  if(i%p==0) break; // 线性的关键  } } return prime; } 关于if(i%p==0) break; 其作用是使得vis数组永远以最小质因数的倍数来标记， 这样vis在整个过程中每个元素只会被标记一次\n假设当前的质数p为p0，后续的质数p为p1，p2，……， 显然后续的p都大于p0，并且i \u0026gt;= p\ni%p==0意味着i可以作如下分解i == p0*a， 如果a \u0026gt; 1，对a再作分解a == pk*b那么一定有pk \u0026gt;= p0， 否则，在遍历到pk时就已经退出， 因此，对于遍历中小于p0质数而言，一定比i的最小质因数更小， 也是因此，vis中的每个元素至多被访问一次\n对于大于p的质数，不妨以p1为例，继续走一步， i*p1 == p1*p0*a == p0*p1*a，显然,i*p1在i走到i1==p1*a时, 一样会被p0标记，因此，没有必要继续， 在i%p == 0时退出，已经能够保证vis中大于2的元素，都至少被访问一次\n最大公因数 源码 inline int gcd(int a, int b) { while(a^=b^=a^=b%=a); return b; } 原理 辗转相除法\n","date":"2021-07-28T00:00:00Z","permalink":"https://awpep.github.io/p/acm-tips/","title":"算法题常用小技巧"},{"content":"正文测试 阿巴阿巴阿巴\n","date":"2021-07-21T00:00:00Z","image":"https://awpep.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://awpep.github.io/p/test-chinese/","title":"中文测试"},{"content":"搬运自我的CSDN博客\nt连接Mysql的时候出现了驱动没有装载的情况，在网上找了很多方法，最终成功使得available drivers当中出现了QMYSQL，但是依然无法加载驱动，折腾了半天终于跟着官方文档解决了问题。想起以前也这么折腾过一次，吸取教训，赶紧记录一下以防日后又忘记。\n背景 Qt版本：Qt 5.13.0 编译器：mingw73_64 MySQL：MySQL Connector C 6.1.11，这里没有安装完整的MySQL，因为仅仅需要连接服务器上的数据库\n踩坑过程 根据网上大部分人的方法，使用Qt的图形化界面对sqldriver目录下mysql.pro进行编译，我的目录是\nF:\\Softwares\\Qt\\5.13.0\\Src\\qtbase\\src\\plugins\\sqldrivers\\mysql 然后把编译生成的两个dll文件，copy至编译器的sqldrivers目录下，我的目录是\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\plugins\\sqldrivers 最后再把MySQL的libmysql.dll复制到编译器的bin目录下，我的目录是\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\bin 然而，编译完成后，结果如下\n可以说，非常的难受\n解决方法 最后在Qt官网找到了解决方案，根据官网的说明，实际上仅需下载MySQL Connector C，另外官网也给了说明\n Note: As of MySQL 8.0.19, the C Connector is no longer offered as a standalone installable component. Instead, you can get mysql.h and libmysql.* by installing the full MySQL Server (x64 only) or the MariaDB C Connector.\n 从8.0.19版本开始不再提供独立的Connector C了\n这里要确定64位的connector要对应64位的Qt，我选择的是64位Archive版(免安装)，确认有以下三个文件\n\u0026lt;MySQL dir\u0026gt;/lib/libmysql.lib \u0026lt;MySQL dir\u0026gt;/lib/libmysql.dll \u0026lt;MySQL dir\u0026gt;/include/mysql.h 随后，打开Qt的命令行工具Qt 5.13.0 (MinGW 7.3.0 64-bit)，输入以下指令\ncd %QTDIR%\\qtbase\\src\\plugins\\sqldrivers qmake -- MYSQL_INCDIR=\u0026quot;C:/Program Files/MySQL/MySQL Connector C 6.1/include\u0026quot; MYSQL_LIBDIR=\u0026quot;C:/Program Files/MySQL/MySQL Connector C 6.1/lib\u0026quot; mingw32-make sub-mysql mingw32-make install 需要将MYSQL_INCDIR和MYSQL_LIBDIR后的路径替换成自己的，例如我的地址是\nMYSQL_INCDIR=\u0026quot;F:\\Tools\\mysql connector c 6.1.11\\include\u0026quot; MYSQL_LIBDIR=\u0026quot;F:\\Tools\\mysql connector c 6.1.11\\lib\u0026quot; 运行完以后会在以下目录生成两个dll文件qsqlmysql.dll、qsqlmysqld.dll（以我为例）\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\plugins\\sqldrivers 最后，再将libmysql.dll复制到以下目录即可（以我为例）\nF:\\Softwares\\Qt\\5.13.0\\mingw73_64\\bin ","date":"2020-05-05T00:00:00Z","image":"https://awpep.github.io/p/about-qmysql-error-solution/Qt_hu0c217fc96746f2cbd58fdf71d137cebd_35026_120x120_fill_box_smart1_2.png","permalink":"https://awpep.github.io/p/about-qmysql-error-solution/","title":"关于Qt中出现QSqlDatabase: QMYSQL driver not loaded的解决方案"},{"content":"搬运自我的CSDN博客\n帮老师做项目的时候遇到了一个奇怪的问题 因为需要几个定时器同步，因此将其中一个定时器配置成主模式，将使能信号作为触发源输出，其他定时器作为从模式触发 但是高级定时器总是莫名其妙被先行被触发，排查后发现，原因来自TimeBaseInit函数，函数原型如下\n/** * @brief Initializes the TIMx Time Base Unit peripheral according to * the specified parameters in the TIM_TimeBaseInitStruct. * @param TIMx: where x can be 1 to 14 to select the TIM peripheral. * @param TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure * that contains the configuration information for the specified TIM peripheral. * @retval None */ void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct) { uint16_t tmpcr1 = 0; /* Check the parameters */ assert_param(IS_TIM_ALL_PERIPH(TIMx)); assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-\u0026gt;TIM_CounterMode)); assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-\u0026gt;TIM_ClockDivision)); tmpcr1 = TIMx-\u0026gt;CR1; if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)|| (TIMx == TIM4) || (TIMx == TIM5)) { /* Select the Counter Mode */ tmpcr1 \u0026amp;= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS)); tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct-\u0026gt;TIM_CounterMode; } if((TIMx != TIM6) \u0026amp;\u0026amp; (TIMx != TIM7)) { /* Set the clock division */ tmpcr1 \u0026amp;= (uint16_t)(~TIM_CR1_CKD); tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct-\u0026gt;TIM_ClockDivision; } TIMx-\u0026gt;CR1 = tmpcr1; /* Set the Autoreload value */ TIMx-\u0026gt;ARR = TIM_TimeBaseInitStruct-\u0026gt;TIM_Period ; /* Set the Prescaler value */ TIMx-\u0026gt;PSC = TIM_TimeBaseInitStruct-\u0026gt;TIM_Prescaler; if ((TIMx == TIM1) || (TIMx == TIM8)) { /* Set the Repetition Counter value */ TIMx-\u0026gt;RCR = TIM_TimeBaseInitStruct-\u0026gt;TIM_RepetitionCounter; } /* Generate an update event to reload the Prescaler and the repetition counter(only for TIM1 and TIM8) value immediately */ TIMx-\u0026gt;EGR = TIM_PSCReloadMode_Immediate; } 可以看到里面有这么一句\n/* Generate an update event to reload the Prescaler and the repetition counter(only for TIM1 and TIM8) value immediately */ TIMx-\u0026gt;EGR = TIM_PSCReloadMode_Immediate; 注释上写的大概意思是通过产生一个更新事件来立即重载预分频寄存器和重复计数寄存器查参考手册找TIM8的EGR寄存器\n继续查右值，发现是个宏\n#define TIM_PSCReloadMode_Immediate ((uint16_t)0x0001) UG位的作用\n作用注释已经解释了，官方的参考手册里面也有讲，是使用更新事件来确保各个装在入影子寄存器的值立即更新，这是一种官方推荐的初始化定时器的方式我的代码里，是先初始化高级定时器，然后初始化通用定时器，高级定时器使用通用定时器作为触发源\n//设置为从模式，用TIM4触发 TIM_SelectSlaveMode(TIM8, TIM_SlaveMode_Trigger); TIM_SelectInputTrigger(TIM8, TIM_TS_ITR2); 然而，当代码运行到通用定时器初始化时，发现TIM8神奇的被触发了，通过之前的分析感觉是UG的问题 可是，我TIM4输出的触发信号明明是使能信号\n//主模式 //该函数是用作主定时器与从定时器触发的同步，并不是设置主定时器 TIM_SelectMasterSlaveMode(TIM4, TIM_MasterSlaveMode_Enable); TIM_SelectOutputTrigger(TIM4, TIM_TRGOSource_Enable); 后来一想，运行到TimeBaseInit时，我还没设置输出的触发源，会不会是这个问题再查数据手册，管理触发源的是CR2寄存器的MMS\n可以看到，复位值是000，那么MMS是000的时候会怎么样呢？\n the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.TIMx_EGR寄存器中的UG位用作触发输出（TRGO）。 如果复位是由触发输入（从机模式控制器配置为复位模式）产生的，则TRGO上的信号与实际复位相比会延迟。\n 至此，终于破案了截图均来自STM32F429参考手册 RM0090 Rev 18\n","date":"2019-12-20T00:00:00Z","image":"https://awpep.github.io/p/about-stm32f429-timer/STM32_huac24df2c7fde356d310dbb0cd27b8db0_1376535_120x120_fill_box_smart1_2.png","permalink":"https://awpep.github.io/p/about-stm32f429-timer/","title":"关于STM32F429中定时器的触发问题"}]