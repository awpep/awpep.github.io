<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 不会C的菜菜</title><link>https://awpep.github.io/post/</link><description>Recent content in Posts on 不会C的菜菜</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 21 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://awpep.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Java学习笔记</title><link>https://awpep.github.io/p/java-tips/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/java-tips/</guid><description>maven maven的生命周期 maven有三套独立的生命周期：clean、default、site
每个生命周期又包含了多个阶段。这些阶段在执行的时候是有固定顺序的。后面的阶段一定要等前面的阶段执行完成后才能被执行。
clean 包含三个阶段：
pre-clean：执行清理前需要完成的工作。 clean：清理上一次构建过程中生成的文件，比如编译后的 class 文件等。 post-clean：执行清理后需要完成的工作。 default 名称 说明 validate 验证项目结构是否正常，必要的配置文件是否存在 initialize 做构建前的初始化操作，比如初始化参数、创建必要的目录等 generate-sources 产生在编译过程中需要的源代码 process-sources 处理源代码，比如过滤值 generate-resources 产生主代码中的资源在 classpath 中的包 process-resources 将资源文件复制到 classpath 的对应包中 compile 编译项目中的源代码 process-classes 产生编译过程中生成的文件 generate-test-sources 产生编译过程中测试相关的代码 process-test-sources 处理测试代码 generate-test-resources 产生测试中资源在 classpath 中的包 process-test-resources 将测试资源复制到 classpath 中 test-compile 编译测试代码 process-test-classes 产生编译测试代码过程的文件 test 运行测试案例 prepare-package 处理打包前需要初始化的准备工作 package 将编译后的 class 和资源打包成压缩文件，比如 rar pre-integration-test 做好集成测试前的准备工作，比如集成环境的参数设置 integration-test 集成测试 post-integration-test 完成集成测试后的收尾工作，比如清理集成环境的值 verify 检测测试后的包是否完好 install 将打包的组件以构件的形式，安装到本地依赖仓库中，以便共享给本地的其他项目 deploy 运行集成和发布环境，将测试后的最终包以构件的方式发布到远程仓库中，方便所有程序员共享 site pre-site：执行生成站点前的准备工作。 site：生成站点文档。 post-site：执行生成站点后需要收尾的工作。 site-deploy：将生成的站点发布到服务器上。</description></item><item><title>Effective C++阅读笔记</title><link>https://awpep.github.io/p/effective-cpp-tips/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/effective-cpp-tips/</guid><description>视C++为一个语言联邦 将C++看作四个次级结构组成的语法体系，每个体系都会有独自的守则
C Object-Oriented C++ Template C++ STL 尽量以const，enum，inline替换#define 例1 例如以下两行代码
#define ASPECT_RATIO 1.653 const double AspectRatio = 1.653; 前者在编译器处理时，仅仅进行简单的替换，而后者为实实在在的变量， 如果在代码中出错，前者在错误信息中会被识别为1.653，而后者会被识别为AspectRatio 显然带有语义的变量能够帮助我们更快地定位问题所在
确定对象被使用前已被初始化 用初始化列表代替赋值 这在效率上更有优势，如下例：
class PhoneNumber {...}; class ABEntry { public: ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones); private: std::string theName; std::string theAddress; std::list&amp;lt;PhoneNumber&amp;gt; thePhones; int numTimesConsulted; } // 使用赋值的方式进行初始化 ABEntry::ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; } // 使用初始化列表 ABEntry::ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones) :theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) {} 使用赋值的方式进行初始化将会先调用成员数据类型的default构造函数， 而后进行拷贝赋值，如此一来，default构造函数相当于做了无用功</description></item><item><title>C++语法笔记</title><link>https://awpep.github.io/p/cpp-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/cpp-tips/</guid><description>关于cv关键字 本节搬运自const关键字放在“类型前”与“类型后”
char * const cp //定义一个指向字符的指针常数 const char* p //定义一个指向字符常数的指针 char const* p //等同于const char* p 关于const unordered_map的特殊之处 const unordered_map不能使用[]重载
//@{ /** * @brief Subscript ( @c [] ) access to %unordered_map data. * @param __k The key for which data should be retrieved. * @return A reference to the data of the (key,data) %pair. * * Allows for easy lookup with the subscript ( @c [] )operator. Returns * data associated with the key specified in subscript.</description></item><item><title>算法题常用小技巧</title><link>https://awpep.github.io/p/acm-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/acm-tips/</guid><description>常用位运算公式 lowbit：取最后一位1 -x&amp;amp;x
去除最后一位1 (x-1)&amp;amp;x
枚举子集
for(int subset = set; subset; subset = (subset-1)&amp;amp;set) GCC内建位运算函数 int __builtin_ffs(unsigned int x) 返回x中最后一个为1的位是从后向前的第几位，如__builtin_ffs(0x789)=1，__builtin_ffs(0x78c)=3。于是，__builtin_ffs(x) - 1就是x中最后一个为1的位的位置。
int __builtin_popcount(unsigned int x) x中1的个数。
int __builtin_ctz(unsigned int x) x末尾0的个数。x=0时结果未定义。
int __builtin_clz(unsigned int x) x前导0的个数。x=0时结果未定义。
int __builtin_parity(unsigned int x) x中1的奇偶性。
上面的宏中x都是unsigned int型的，如果传入signed或者是char型，会被强制转换成unsigned int。
质因数分解 参考来源：力扣（LeetCode）
作者：xin-xiang-yuan-fang
源码 // 质因数分解 vector&amp;lt;int&amp;gt; vec; for (int i = 2; i &amp;lt;= n/i; ++i) { bool flag = false; while (n % i == 0) { n /= i; flag = true; } if(flag) vec.</description></item><item><title>中文测试</title><link>https://awpep.github.io/p/test-chinese/</link><pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/test-chinese/</guid><description>正文测试 阿巴阿巴阿巴</description></item><item><title>关于Qt中出现QSqlDatabase: QMYSQL driver not loaded的解决方案</title><link>https://awpep.github.io/p/about-qmysql-error-solution/</link><pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/about-qmysql-error-solution/</guid><description>搬运自我的CSDN博客
t连接Mysql的时候出现了驱动没有装载的情况，在网上找了很多方法，最终成功使得available drivers当中出现了QMYSQL，但是依然无法加载驱动，折腾了半天终于跟着官方文档解决了问题。想起以前也这么折腾过一次，吸取教训，赶紧记录一下以防日后又忘记。
背景 Qt版本：Qt 5.13.0 编译器：mingw73_64 MySQL：MySQL Connector C 6.1.11，这里没有安装完整的MySQL，因为仅仅需要连接服务器上的数据库
踩坑过程 根据网上大部分人的方法，使用Qt的图形化界面对sqldriver目录下mysql.pro进行编译，我的目录是
F:\Softwares\Qt\5.13.0\Src\qtbase\src\plugins\sqldrivers\mysql 然后把编译生成的两个dll文件，copy至编译器的sqldrivers目录下，我的目录是
F:\Softwares\Qt\5.13.0\mingw73_64\plugins\sqldrivers 最后再把MySQL的libmysql.dll复制到编译器的bin目录下，我的目录是
F:\Softwares\Qt\5.13.0\mingw73_64\bin 然而，编译完成后，结果如下
可以说，非常的难受
解决方法 最后在Qt官网找到了解决方案，根据官网的说明，实际上仅需下载MySQL Connector C，另外官网也给了说明
Note: As of MySQL 8.0.19, the C Connector is no longer offered as a standalone installable component. Instead, you can get mysql.h and libmysql.* by installing the full MySQL Server (x64 only) or the MariaDB C Connector.
从8.0.19版本开始不再提供独立的Connector C了
这里要确定64位的connector要对应64位的Qt，我选择的是64位Archive版(免安装)，确认有以下三个文件
&amp;lt;MySQL dir&amp;gt;/lib/libmysql.lib &amp;lt;MySQL dir&amp;gt;/lib/libmysql.dll &amp;lt;MySQL dir&amp;gt;/include/mysql.</description></item><item><title>关于STM32F429中定时器的触发问题</title><link>https://awpep.github.io/p/about-stm32f429-timer/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/about-stm32f429-timer/</guid><description>搬运自我的CSDN博客
帮老师做项目的时候遇到了一个奇怪的问题 因为需要几个定时器同步，因此将其中一个定时器配置成主模式，将使能信号作为触发源输出，其他定时器作为从模式触发 但是高级定时器总是莫名其妙被先行被触发，排查后发现，原因来自TimeBaseInit函数，函数原型如下
/** * @brief Initializes the TIMx Time Base Unit peripheral according to * the specified parameters in the TIM_TimeBaseInitStruct. * @param TIMx: where x can be 1 to 14 to select the TIM peripheral. * @param TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure * that contains the configuration information for the specified TIM peripheral. * @retval None */ void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct) { uint16_t tmpcr1 = 0; /* Check the parameters */ assert_param(IS_TIM_ALL_PERIPH(TIMx)); assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&amp;gt;TIM_CounterMode)); assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&amp;gt;TIM_ClockDivision)); tmpcr1 = TIMx-&amp;gt;CR1; if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)|| (TIMx == TIM4) || (TIMx == TIM5)) { /* Select the Counter Mode */ tmpcr1 &amp;amp;= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS)); tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct-&amp;gt;TIM_CounterMode; } if((TIMx !</description></item></channel></rss>