<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>不会C的菜菜</title><link>https://awpep.github.io/</link><description>Recent content on 不会C的菜菜</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 28 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://awpep.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>C++语法笔记</title><link>https://awpep.github.io/p/cpp-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/cpp-tips/</guid><description>&lt;h2 id="关于cv关键字">关于cv关键字&lt;/h2>
&lt;p>本节搬运自&lt;a class="link" href="https://blog.csdn.net/jamesmf/article/details/4653926" target="_blank" rel="noopener"
>const关键字放在“类型前”与“类型后”&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">cp&lt;/span> &lt;span class="c1">//定义一个指向字符的指针常数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="c1">//定义一个指向字符常数的指针
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="k">const&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="c1">//等同于const char* p
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关于求值顺序">关于求值顺序&lt;/h2>
&lt;p>本节搬运自&lt;a class="link" href="https://www.cnblogs.com/jiayouwyhit/p/3147310.html" target="_blank" rel="noopener"
>【部分原创】标准C语言的优先级、结合性、求值顺序、未定义行为和非确定行为浅析&lt;/a>&lt;/p>
&lt;p>在C语言中，仅有少数运算符在标准中有规定表达式求值的顺序&lt;/p>
&lt;h3 id="逻辑与或">逻辑与或&lt;/h3>
&lt;p>&lt;code>&amp;amp;&amp;amp;&lt;/code>和&lt;code>||&lt;/code>规定从左到右求值，并且在能确定整个表达式的值的时候就会停止，也就是 常说的短路&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//结果：x == 2, y == 1, z == 1
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="条件表达式">条件表达式&lt;/h3>
&lt;p>条件表达式的求值顺序是这样规定的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">test&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">exp1&lt;/span> &lt;span class="err">：&lt;/span> &lt;span class="n">exp2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>条件测试部分&lt;code>test&lt;/code>非零，表达式&lt;code>exp1&lt;/code>被求值，否则表达式&lt;code>exp2&lt;/code>被求值，并且保证&lt;code>exp1&lt;/code>和&lt;code>exp2&lt;/code>两者之中只有一个被求值&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">z&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="nl">y&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//结果：x == 1, y == 1, z == 0;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="逗号运算符">逗号运算符&lt;/h3>
&lt;p>逗号运算符的求值顺序是从左到右顺序求值，并且整个表达式的值等于最后一个表达式的值，注意逗号&lt;code>,&lt;/code>还可以作为函数参数的分隔符，变量定义的分隔符等，这时候表达式的求值顺序是没有规定的！&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;1st&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">else&lt;/span> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;2nd&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//结果：2nd
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关于template">关于template&lt;/h2>
&lt;h3 id="萃取机制">萃取机制&lt;/h3>
&lt;h4 id="内嵌型别">内嵌型别&lt;/h4>
&lt;p>个人理解，所谓&lt;em>内嵌型别&lt;/em>就是在类的内部使用&lt;code>typedef&lt;/code>给类型定义别名，常常与模板相结合&lt;br>
举个栗子&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">SubType&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码中&lt;code>MyClass&lt;/code>这个类在内部给&lt;code>int&lt;/code>取了一个别名叫&lt;code>SubType&lt;/code>，于是乎，我可以用&lt;code>MyClass::SubType&lt;/code>来指代&lt;code>int&lt;/code>&lt;br>
这个操作乍一看有点脱裤子放屁的感觉，事实上其功用远超想象&lt;/p>
&lt;h4 id="typename关键字">typename关键字&lt;/h4>
&lt;p>&lt;em>C++的一般规则是，除了使用typename修饰之外，template内的任何标识符号都被视为一个值而不是一个类别(对象)&lt;/em>&lt;/p>
&lt;p>假设我希望实现一个模板类，在其内部需要声明一个类型&lt;code>T&lt;/code>的内嵌型&lt;code>SubType&lt;/code>的指针，于是有了这么一段看似可行代码&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">T&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">SubType&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>事实上，在编译器看来，&lt;code>SubType&lt;/code>会被当成一个&lt;code>static&lt;/code>成员，于是&lt;code>T::SubType *ptr&lt;/code>会被解释为型别&lt;code>T&lt;/code>内的数值&lt;code>SubType&lt;/code>与&lt;code>ptr&lt;/code>的乘积&lt;br>
正确的写法如下&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">SubType&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>typename&lt;/code>指出&lt;code>SubType&lt;/code>是&lt;code>class T&lt;/code>中定义的一个类别，因此&lt;code>ptr&lt;/code>是一个指向&lt;code>T::SubType&lt;/code>型别的指针。&lt;/p>
&lt;h4 id="迭代器与萃取">迭代器与萃取&lt;/h4>
&lt;p>迭代器有一个重要的功能，就是实现类似取地址内容的操作，这个操作迭代器在声明时通过重载&lt;code>*&lt;/code>实现&lt;br>
现在假设需要实现这么一个函数，参数是一个迭代器，返回值是迭代器指向的内容，一种直观的想法如下&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyIter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 内嵌型别声明
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">MyIter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">I&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">I&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">I&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，这种写法是不行的，问题颇多&lt;br>
首先&lt;code>(*T)&lt;/code>会被理解为一种操作而非类型声明，就好像&lt;code>*MyIter&lt;/code>，对一个类，而非对象取址，不伦不类&lt;br>
那，如果加上&lt;code>typname&lt;/code>呢？&lt;br>
很遗憾，也不可以，&lt;code>typename&lt;/code>只对&lt;code>T&lt;/code>内部的标识符号起作用&lt;/p>
&lt;p>这时就需要利用内嵌型别声明&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyIter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 内嵌型别声明
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">MyIter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">I&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">typename&lt;/span> &lt;span class="n">I&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">value_type&lt;/span>
&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">I&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;class version&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">MyIter&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出8
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看似很ok，但是如果传入的是一个原生指针，例如&lt;code>int*&lt;/code>，那么编译就无法通过&lt;br>
可以用偏特化解决&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyIter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 内嵌型别声明
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">MyIter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">I&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">typename&lt;/span> &lt;span class="n">I&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">value_type&lt;/span>
&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">I&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;class version&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">I&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="n">I&lt;/span>
&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">I&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;pointer version&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">I&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="n">I&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">I&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;const pointer version&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">MyIter&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">52&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，如此这般需要对每一个函数都进行偏特化，会造成大量的代码冗余，为了提高代码重用，STL加入了一个中间层，也就是iterator_Traits&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyIter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 内嵌型别声明
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">MyIter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">// class type
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">iterator_traits&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">value_type&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">// 偏特化1
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">iterator_traits&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">// 偏特化2
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">iterator_traits&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">I&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="k">typename&lt;/span> &lt;span class="n">iterator_traits&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">I&lt;/span>&lt;span class="o">&amp;gt;::&lt;/span>&lt;span class="n">value_type&lt;/span>
&lt;span class="c1">// 首先询问iterator_traits&amp;lt;I&amp;gt;::value_type,如果传递的I为指针,则进入特化版本,iterator_traits直接回答;如果传递进来的I为class type,就去询问T::value_type.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">I&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;normal version&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">MyIter&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ite&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">52&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>萃取机制为模板使用中的类型声明问题提供了一种通用的实现方式，避免了使用&lt;code>value_types&lt;/code>的函数都需要进行偏特化设计的尴尬&lt;/p>
&lt;h2 id="关于左值和右值todo">关于左值和右值(TODO)&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a class="link" href="https://blog.csdn.net/jamesmf/article/details/4653926" target="_blank" rel="noopener"
>const关键字放在“类型前”与“类型后”&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.cnblogs.com/jiayouwyhit/p/3147310.html" target="_blank" rel="noopener"
>【部分原创】标准C语言的优先级、结合性、求值顺序、未定义行为和非确定行为浅析&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.cnblogs.com/cthon/p/9201649.html" target="_blank" rel="noopener"
>C++模板之typename和class关键字的区别&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/85809752" target="_blank" rel="noopener"
>C++ STL 源码剖析之 Traits 编程技法&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>算法题常用小技巧</title><link>https://awpep.github.io/p/acm-tips/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/acm-tips/</guid><description>&lt;h2 id="常用位运算公式">常用位运算公式&lt;/h2>
&lt;p>lowbit：取最后一位1 &lt;code>-x&amp;amp;x&lt;/code>&lt;br>
去除最后一位1 &lt;code>(x-1)&amp;amp;x&lt;/code>&lt;br>
枚举子集&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">subset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">set&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">subset&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">subset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">subset&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">set&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="gcc内建位运算函数">GCC内建位运算函数&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">__builtin_ffs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回&lt;code>x&lt;/code>中最后一个为1的位是从后向前的第几位，如&lt;code>__builtin_ffs(0x789)=1&lt;/code>，&lt;code>__builtin_ffs(0x78c)=3&lt;/code>。于是，&lt;code>__builtin_ffs(x) - 1&lt;/code>就是&lt;code>x&lt;/code>中最后一个为1的位的位置。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">__builtin_popcount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>x&lt;/code>中1的个数。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">__builtin_ctz&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>x&lt;/code>末尾0的个数。&lt;code>x=0&lt;/code>时结果未定义。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">__builtin_clz&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>x&lt;/code>前导0的个数。&lt;code>x=0&lt;/code>时结果未定义。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">int&lt;/span> &lt;span class="n">__builtin_parity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>x&lt;/code>中1的奇偶性。&lt;/p>
&lt;p>上面的宏中&lt;code>x&lt;/code>都是&lt;code>unsigned int&lt;/code>型的，如果传入&lt;code>signed&lt;/code>或者是&lt;code>char&lt;/code>型，会被强制转换成&lt;code>unsigned int&lt;/code>。&lt;/p></description></item><item><title>中文测试</title><link>https://awpep.github.io/p/test-chinese/</link><pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/test-chinese/</guid><description>&lt;img src="https://awpep.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash.jpg" alt="Featured image of post 中文测试" />&lt;h2 id="正文测试">正文测试&lt;/h2>
&lt;p>阿巴阿巴阿巴&lt;/p></description></item><item><title>关于Qt中出现QSqlDatabase: QMYSQL driver not loaded的解决方案</title><link>https://awpep.github.io/p/about-qmysql-error-solution/</link><pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/about-qmysql-error-solution/</guid><description>&lt;img src="https://awpep.github.io/p/about-qmysql-error-solution/Qt.png" alt="Featured image of post 关于Qt中出现QSqlDatabase: QMYSQL driver not loaded的解决方案" />&lt;p>搬运自我的&lt;a class="link" href="https://blog.csdn.net/qq_43626382/article/details/105928356" target="_blank" rel="noopener"
>CSDN博客&lt;/a>&lt;/p>
&lt;p>t连接Mysql的时候出现了驱动没有装载的情况，在网上找了很多方法，最终成功使得available drivers当中出现了QMYSQL，但是依然无法加载驱动，折腾了半天终于跟着官方文档解决了问题。想起以前也这么折腾过一次，吸取教训，赶紧记录一下以防日后又忘记。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>Qt版本：&lt;strong>Qt 5.13.0&lt;/strong>
编译器：&lt;strong>mingw73_64&lt;/strong>
MySQL：&lt;strong>MySQL Connector C 6.1.11&lt;/strong>，这里没有安装完整的MySQL，因为仅仅需要连接服务器上的数据库&lt;/p>
&lt;h2 id="踩坑过程">踩坑过程&lt;/h2>
&lt;p>根据网上大部分人的方法，使用Qt的图形化界面对sqldriver目录下mysql.pro进行编译，我的目录是&lt;/p>
&lt;pre>&lt;code>F:\Softwares\Qt\5.13.0\Src\qtbase\src\plugins\sqldrivers\mysql
&lt;/code>&lt;/pre>&lt;p>然后把编译生成的两个dll文件，copy至编译器的sqldrivers目录下，我的目录是&lt;/p>
&lt;pre>&lt;code>F:\Softwares\Qt\5.13.0\mingw73_64\plugins\sqldrivers
&lt;/code>&lt;/pre>&lt;p>最后再把MySQL的&lt;strong>libmysql.dll&lt;/strong>复制到编译器的bin目录下，我的目录是&lt;/p>
&lt;pre>&lt;code>F:\Softwares\Qt\5.13.0\mingw73_64\bin
&lt;/code>&lt;/pre>&lt;p>然而，编译完成后，结果如下&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200505103916319.png" alt="在这里插入图片描述" />&lt;/p>
&lt;p>可以说，非常的难受&lt;/p>
&lt;h2 id="解决方法">解决方法&lt;/h2>
&lt;p>最后在&lt;a class="link" href="https://doc.qt.io/qt-5/sql-driver.html#qmysql-for-mysql-5-and-higher" target="_blank" rel="noopener"
>Qt官网&lt;/a>找到了解决方案，根据官网的说明，实际上仅需下载&lt;a class="link" href="https://downloads.mysql.com/archives/c-c/" target="_blank" rel="noopener"
>MySQL Connector C&lt;/a>，另外官网也给了说明&lt;/p>
&lt;blockquote>
&lt;p>Note: As of MySQL 8.0.19, the C Connector is no longer offered as a standalone installable component. Instead, you can get mysql.h and libmysql.* by installing the full MySQL Server (x64 only) or the MariaDB C Connector.&lt;/p>
&lt;/blockquote>
&lt;p>从8.0.19版本开始不再提供独立的Connector C了&lt;/p>
&lt;p>这里要确定64位的connector要对应64位的Qt，我选择的是64位Archive版(免安装)，确认有以下三个文件&lt;/p>
&lt;pre>&lt;code>&amp;lt;MySQL dir&amp;gt;/lib/libmysql.lib
&amp;lt;MySQL dir&amp;gt;/lib/libmysql.dll
&amp;lt;MySQL dir&amp;gt;/include/mysql.h
&lt;/code>&lt;/pre>&lt;p>随后，打开Qt的命令行工具&lt;strong>Qt 5.13.0 (MinGW 7.3.0 64-bit)&lt;/strong>，输入以下指令&lt;/p>
&lt;pre>&lt;code>cd %QTDIR%\qtbase\src\plugins\sqldrivers
qmake -- MYSQL_INCDIR=&amp;quot;C:/Program Files/MySQL/MySQL Connector C 6.1/include&amp;quot; MYSQL_LIBDIR=&amp;quot;C:/Program Files/MySQL/MySQL Connector C 6.1/lib&amp;quot;
mingw32-make sub-mysql
mingw32-make install
&lt;/code>&lt;/pre>&lt;p>需要将&lt;strong>MYSQL_INCDIR&lt;/strong>和&lt;strong>MYSQL_LIBDIR&lt;/strong>后的路径替换成自己的，例如我的地址是&lt;/p>
&lt;pre>&lt;code>MYSQL_INCDIR=&amp;quot;F:\Tools\mysql connector c 6.1.11\include&amp;quot;
MYSQL_LIBDIR=&amp;quot;F:\Tools\mysql connector c 6.1.11\lib&amp;quot;
&lt;/code>&lt;/pre>&lt;p>运行完以后会在以下目录生成两个dll文件&lt;strong>qsqlmysql.dll&lt;/strong>、&lt;strong>qsqlmysqld.dll&lt;/strong>（以我为例）&lt;/p>
&lt;pre>&lt;code>F:\Softwares\Qt\5.13.0\mingw73_64\plugins\sqldrivers
&lt;/code>&lt;/pre>&lt;p>最后，再将&lt;strong>libmysql.dll&lt;/strong>复制到以下目录即可（以我为例）&lt;/p>
&lt;pre>&lt;code>F:\Softwares\Qt\5.13.0\mingw73_64\bin
&lt;/code>&lt;/pre></description></item><item><title>关于STM32F429中定时器的触发问题</title><link>https://awpep.github.io/p/about-stm32f429-timer/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://awpep.github.io/p/about-stm32f429-timer/</guid><description>&lt;img src="https://awpep.github.io/p/about-stm32f429-timer/STM32.png" alt="Featured image of post 关于STM32F429中定时器的触发问题" />&lt;p>搬运自我的&lt;a class="link" href="https://blog.csdn.net/qq_43626382/article/details/103636001" target="_blank" rel="noopener"
>CSDN博客&lt;/a>&lt;/p>
&lt;p>帮老师做项目的时候遇到了一个奇怪的问题
因为需要几个定时器同步，因此将其中一个定时器配置成主模式，将使能信号作为触发源输出，其他定时器作为从模式触发
但是高级定时器总是莫名其妙被先行被触发，排查后发现，原因来自&lt;strong>TimeBaseInit&lt;/strong>函数，函数原型如下&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * @brief Initializes the TIMx Time Base Unit peripheral according to
&lt;/span>&lt;span class="cm"> * the specified parameters in the TIM_TimeBaseInitStruct.
&lt;/span>&lt;span class="cm"> * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
&lt;/span>&lt;span class="cm"> * @param TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
&lt;/span>&lt;span class="cm"> * that contains the configuration information for the specified TIM peripheral.
&lt;/span>&lt;span class="cm"> * @retval None
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">TIM_TimeBaseInit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM_TypeDef&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">TIMx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIM_TimeBaseInitTypeDef&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">uint16_t&lt;/span> &lt;span class="n">tmpcr1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cm">/* Check the parameters */&lt;/span>
&lt;span class="n">assert_param&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IS_TIM_ALL_PERIPH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">assert_param&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IS_TIM_COUNTER_MODE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_CounterMode&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">assert_param&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IS_TIM_CKD_DIV&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_ClockDivision&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">tmpcr1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CR1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM8&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">||&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM3&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">||&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM5&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="cm">/* Select the Counter Mode */&lt;/span>
&lt;span class="n">tmpcr1&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint16_t&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="o">~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM_CR1_DIR&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">TIM_CR1_CMS&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">tmpcr1&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint32_t&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_CounterMode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">TIM6&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">TIM7&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="cm">/* Set the clock division */&lt;/span>
&lt;span class="n">tmpcr1&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint16_t&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="o">~&lt;/span>&lt;span class="n">TIM_CR1_CKD&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">tmpcr1&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint32_t&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_ClockDivision&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CR1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmpcr1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cm">/* Set the Autoreload value */&lt;/span>
&lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ARR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_Period&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="cm">/* Set the Prescaler value */&lt;/span>
&lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">PSC&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_Prescaler&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">TIMx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TIM8&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="cm">/* Set the Repetition Counter value */&lt;/span>
&lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">RCR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TIM_TimeBaseInitStruct&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">TIM_RepetitionCounter&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/* Generate an update event to reload the Prescaler
&lt;/span>&lt;span class="cm"> and the repetition counter(only for TIM1 and TIM8) value immediately */&lt;/span>
&lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">EGR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TIM_PSCReloadMode_Immediate&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到里面有这么一句&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/* Generate an update event to reload the Prescaler
&lt;/span>&lt;span class="cm"> and the repetition counter(only for TIM1 and TIM8) value immediately */&lt;/span>
&lt;span class="n">TIMx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">EGR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TIM_PSCReloadMode_Immediate&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注释上写的大概意思是通过产生一个更新事件来立即重载预分频寄存器和重复计数寄存器&lt;!-- raw HTML omitted -->
查参考手册找TIM8的EGR寄存器&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20191220181454750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI2Mzgy,size_16,color_FFFFFF,t_70" alt="来自RM0090 Rev 18" />&lt;/p>
&lt;p>继续查右值，发现是个宏&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TIM_PSCReloadMode_Immediate ((uint16_t)0x0001)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>UG位的作用&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20191220172017231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI2Mzgy,size_16,color_FFFFFF,t_70" alt="UG位" />&lt;/p>
&lt;p>作用注释已经解释了，官方的参考手册里面也有讲，是使用更新事件来确保各个装在入影子寄存器的值立即更新，这是一种官方推荐的初始化定时器的方式&lt;!-- raw HTML omitted -->
我的代码里，是先初始化高级定时器，然后初始化通用定时器，高级定时器使用通用定时器作为触发源&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//设置为从模式，用TIM4触发
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">TIM_SelectSlaveMode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIM_SlaveMode_Trigger&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">TIM_SelectInputTrigger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIM_TS_ITR2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，当代码运行到通用定时器初始化时，发现TIM8神奇的被触发了，通过之前的分析感觉是UG的问题
可是，我TIM4输出的触发信号明明是使能信号&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//主模式
&lt;/span>&lt;span class="c1">//该函数是用作主定时器与从定时器触发的同步，并不是设置主定时器
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">TIM_SelectMasterSlaveMode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIM_MasterSlaveMode_Enable&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">TIM_SelectOutputTrigger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TIM4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TIM_TRGOSource_Enable&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>后来一想，运行到&lt;strong>TimeBaseInit&lt;/strong>时，我还没设置输出的触发源，会不会是这个问题&lt;!-- raw HTML omitted -->
再查数据手册，管理触发源的是CR2寄存器的MMS&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20191220184317107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI2Mzgy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />&lt;/p>
&lt;p>可以看到，复位值是000，那么MMS是000的时候会怎么样呢？&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20191220184454402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI2Mzgy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />&lt;/p>
&lt;blockquote>
&lt;p>the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.&lt;!-- raw HTML omitted -->
TIMx_EGR寄存器中的UG位用作触发输出（TRGO）。 如果复位是由触发输入（从机模式控制器配置为复位模式）产生的，则TRGO上的信号与实际复位相比会延迟。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;/blockquote>
&lt;p>至此，终于破案了&lt;!-- raw HTML omitted -->
截图均来自STM32F429参考手册 RM0090 Rev 18&lt;/p>
&lt;!-- raw HTML omitted --></description></item></channel></rss>